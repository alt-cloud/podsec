#!/bin/sh

export TEXTDOMAINDIR='/usr/share/locale'
export TEXTDOMAIN='podsec-k8s-upgrade'

function getRegistry() {
  echo 'registry.local'
}

# Устанавливает переменную U7S_PLATFORM
function getPlatform() {
  if [ -n "$U7S_PLATFORM" ]
  then
    echo "Версия платформы $U7S_PLATFORM преопределена переменной U7S_PLATFORM. Принимается это значение." >&2
    return
  fi
  source /etc/os-release
  if [ -n "$ALT_BRANCH_ID" ]
  then
    if [ "$ALT_BRANCH_ID"  == 'sisyphus' ]
    then
      export U7S_PLATFORM="k8s-sisyphus";
    else
      export U7S_PLATFORM="k8s-$ALT_BRANCH_ID"
    fi
  else
    ifs=$IFS
    IFS=:
    set -- $CPE_NAME
    IFS=$ifs
    platform=$4
    version=$5
    IFS=.
    set -- $version
    IFS=$ifs
    version=$1
    case $platform in
      spserver) export U7S_PLATFORM="k8s-c${version}f1"; break;;
      sisyphus) export U7S_PLATFORM="k8s-sisyphus"; break;;
      *) export U7S_PLATFORM="k8s-p${version}"; break;;
    esac
  fi
}


function getRequiredNodeImages() {
  kubeVersion=$1
  isControlPlane=$2
  requiredNodeImages=$(machinectl shell u7s-admin@ \
    /usr/libexec/podsec/u7s/bin/nsenter_u7s \
      /usr/bin/kubeadm -v 0  config images list \
        --image-repository=$U7S_REGISTRYPATH \
        --kubernetes-version=v${kubeVersion} 2>/dev/null |
        grep $U7S_REGISTRYPATH |
        tr -d '\r')
  for Image in $requiredNodeImages
  do
    image=$(basename $Image)
    if [ "$isControlPlane" = 'false' -a ${image:0:10} != 'kube-proxy' ]; then continue; fi # Для WORKER только kube-proxy
    echo $image
  done |
  sort
}

function getCurrentKubeadmVersion() {
  kubeadmVersion=$(kubeadm version -o json | jq -r .clientVersion.gitVersion)
  echo ${kubeadmVersion:1}
}

function getCurrentFlannelVersion() {
  ret=''
  flannelImage=$(kubectl -n kube-flannel get daemonset.apps/kube-flannel-ds -o yaml |
    yq  -r '.spec.template.spec.containers[0].image')
  if [ -n "$flannelImage" ]
  then
    flannelImage=$(basename $flannelImage)
    ifs=$IFS; IFS=:; set -- $flannelImage; IFS=$ifs; ret=${2:1}
  fi
  echo -ne $ret
}

function isVersion() {
  version=$1
	ifs=$IFS
	IFS=.
	set -- $version
	IFS=$ifs
	major=$1
	if [ "${major:0:1}" = 'v' ]; then major=${major:1}; fi
	minor=$2
	patch=$3
	if [[ "$major" -gt 0 && "$minor" -gt 0  && "$patch" -gt 0 ]]
	then
    return 0
  else
    return 1
  fi
}

function getKubeletNodeVerion() {
  node=$1
  ret=$(kubectl get nodes -o json |
    jq -r  '.items[] | select(.metadata.name=="'$node'") | .status.nodeInfo.kubeletVersion')
  while ! isVersion $ret
  do
    echo "$(gettext 'Waiting to be ready for node') $node" >&2
    sleep 5
    ret=$(kubectl get nodes -o json |
      jq -r  '.items[] | select(.metadata.name=="'$node'") | .status.nodeInfo.kubeletVersion')
  done
  echo $ret
}

function getKubeletMinorVerion() {
  node=$1
  ret=$(getKubeletNodeVerion $node)
  if [ -n "$ret" ]
  then
    ret=$(getMinorVersion $ret)
  fi
  echo -ne $ret
}

function getNodeCurrentKubeletVersion() {
  ret=''
  nodeKubeletVersion=$(getKubeletNodeVerion $U7S_HOSTNAME)
  if [ -n "$nodeKubeletVersion" ]
  then
    ret=${nodeKubeletVersion:1}
  fi
  echo -ne $ret
}

function getCurrentKubeAPIVersion() {
  ret=''
  kubeapiVersion=$(kubectl -n kube-system get pods -o json |
    jq -r '.items[] | select(.metadata.name=="kube-apiserver-'${U7S_HOSTNAME}'") | .spec.containers[0].image')

  if [ -n "$kubeapiVersion" ]
  then
    kubeapiVersion=$(basename $kubeapiVersion)
    ifs=$IFS; IFS=:; set -- $kubeapiVersion; IFS=$ifs; ret=${2:1}
  fi
  echo -ne $ret
}


function getKubeProxyMinorVerion() {
  node=$1
  ret=''
  kubeProxyImage=$(
    kubectl  get all -A -o json |
    jq -r '
      .items[] |
      select(.metadata.generateName=="kube-proxy-") |
      if .spec.nodeName=="'$node'" then .spec.containers[0].image
      else empty
      end'
    )
  kubeProxyImage=$(basename $kubeProxyImage)
  ifs=$IFS; IFS=:; set -- $kubeProxyImage; IFS=$ifs; ret=${2:1}
  echo -ne $ret
}

function getCurrentKubeServiceVerion() {
  serviceName=$1
  ret=''
  kubeapiVersion=$(kubectl -n kube-system get pods -o json |
    jq -r '.items[] | select(.metadata.name=="'$serviceName'-'${U7S_HOSTNAME}'") | .spec.containers[0].image')
  if [ -n "$kubeapiVersion" ]
  then
    kubeapiVersion=$(basename $kubeapiVersion)
    ifs=$IFS; IFS=:; set -- $kubeapiVersion; IFS=$ifs; ret=${2}
    if [ "${ret:0:1}" = 'v' ]; then ret=${ret:1}; fi
  fi
  echo -ne $ret
}

function getMinorVersion() {
  if [ -z "$1" ]; then echo -ne ''; fi
	ifs=$IFS
	IFS=.
	set -- $1
	IFS=$ifs
	major=$1
	if [ "${major:0:1}" = 'v' ]; then major=${major:1}; fi
	minor=$2
	echo -ne "$major.$minor"
}

function getPrevMinorVersion() {
	ifs=$IFS
	IFS=.
	set -- $1
	IFS=$ifs
	let prev=$2-1
	echo -ne "$1.$prev"
}

# Вывести список последующих доступных минорных версий
function getNextKubeVersions() {
  curMinorKubeVersion=$1
  toMinorVersion=$2
  if [ $U7S_REGISTRY == 'registry.local' ]
  then
    protocol='http'
  else
    protocol='https'
  fi
  kubeVersions=$(curl -sk $protocol://$U7S_REGISTRY/v2/${U7S_PLATFORM}/kube-apiserver/tags/list | jq -r .tags[] | sort -V)
  ret=''
  lastMinorKubeVersion=$curMinorKubeVersion
  lastPatchKubeVersion=''
  for kubeVersion in $kubeVersions
  do
    if [ "${kubeVersion:0:1}" != 'v' ]; then continue; fi
    kubeVersion=${kubeVersion:1}
    curMinor=$(getMinorVersion $kubeVersion)
    if [[ "$curMinor" > "$curMinorKubeVersion" ]]
    then
      if [ -n "$lastPatchKubeVersion" -a "$curMinor" != "$lastMinorKubeVersion" ]
      then
        ret+="$lastPatchKubeVersion\n"
      fi
    else
      continue
    fi
    if [ -n "${toMinorVersion}" ]
    then
      if [[ "${kubeVersion:0:${#toMinorVersion}}" > "${toMinorVersion}" ]]
      then
        break
      fi
    fi
    lastPatchKubeVersion=$kubeVersion
    lastMinorKubeVersion=$curMinor
  done
  ret+="$lastPatchKubeVersion\n"
  ret="$(echo -ne "$ret" | sort -uV)"
  echo $ret
}

function getPrevKubeMinorVersions() {
  curMinorKubeVersion=$1
  prevMinorKubeVersion='1.26'
  ret=''
  ifs=$IFS
  while [[ "$prevMinorKubeVersion" < "$curMinorKubeVersion" ]]
  do
    ret+=" $prevMinorKubeVersion"
    IFS=.
    set -- $prevMinorKubeVersion
    IFS=$ifs
    let nextMinor=$2+1
    prevMinorKubeVersion="$1.$nextMinor"
  done
  echo -ne $ret
}

function setRPMRegistries() {
  if [ "$U7S_REGISTRY" = 'registry.local' ]
  then
    apt-repo add 'rpm http://sigstore.local:81/kubernetes_upgrade x86_64 main'
    export U7S_RPMRegistryClassic='http://sigstore.local:81/kubernetes_upgrade/x86_64/RPMS.main/'
    export U7S_RPMRegistryNoarch='http://sigstore.local:81/kubernetes_upgrade/x86_64/RPMS.main/'
  elif [ "${U7S_PLATFORM:0:8}" = 'k8s-c10f' ]
  then
    apt-repo add 'rpm [cert8] http://update.altsp.su/pub/distributions/ALTLinux c10f/branch/x86_64-i586 classic'
    apt-repo add 'rpm [cert8] http://update.altsp.su/pub/distributions/ALTLinux c10f/branch/noarch classic'
    export U7S_RPMRegistryClassic="http://update.altsp.su/${U7S_PLATFORM:4}/branch/x86_64/RPMS.classic"
    export U7S_RPMRegistryNoarch="http://update.altsp.su/${U7S_PLATFORM:4}/branch/noarch/RPMS.classic"
  fi
}

function loadRpmPackages() {
  kubeVersions="$*"
  echo "$(gettext 'Loading RPM packages for') $kubeVersions" >&2
  export U7S_rpmDir='/var/cache/apt/archives'
  for kubeVersion in $kubeVersions
  do
    kubeMinorVersion=$(getMinorVersion $kubeVersion)
    apt-get install -d -y \
      kubernetes${kubeMinorVersion}-kubelet\
      kubernetes${kubeMinorVersion}-common\
      kubernetes${kubeMinorVersion}-kubeadm
  done
  echo $U7S_rpmDir
}

function listCordonedNodes() {
  ret=$(kubectl  get nodes -o json |
    jq -r '
      .items[] |
      if .spec.unschedulable!=null
      then .metadata.name
      else empty
      end')
      echo -ne $ret
}

function getDeltaMinorVersions() {
  minor1=$1
  minor2=$2
  ifs=$IFS;IFS=.;
  set -- $minor1
  let Minor1=$1*1000+$2
  set -- $minor2
  let Minor2=$1*1000+$2
  IFS=$ifs
  let ret=$Minor1-$Minor2
  echo -ne $ret
}

function getMembersOfPodsecDev() {
  if members=$(getent group podman_dev) 2</dev/null
  then
    ifs=$IFS
    IFS=:
    set -- $members
    IFS=$ifs
    while [ $# -gt 1 ]; do shift; done
    echo $1
  else
    echo ''
  fi
}

function getPGPMemberOfPodsecDev() {
  members=$(getMembersOfPodsecDev)
  ifs=$IFS
  IFS=,
  set -- $members
  IFS=$ifs
  for user
  do
    if machinectl shell $user@ /usr/bin/gpg2 -k | grep uid >/dev/null 2>&1
    then
      echo $user
      return
    fi
  done
}

function getUserGPGUid() {
  set -- $(machinectl shell $user@ /bin/gpg -k | grep uid)
  shift
  echo $@
}


